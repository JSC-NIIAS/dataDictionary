\documentclass[parskip=half,paper=a4,DIV=13]{scrartcl}

\input{preamble}

\title{Representation of C Structures in Bit Streams}

\author{Timon Lapawczyk \and Jens Gerlach}

\begin{document}

\maketitle

\section{Introduction}

We want to transmit simple C structures (packets) via bit streams.
The C structures consist of members of various (unsigned) integer types.
Moreover, it might happen that only a certain number of bits of a member
shall be transmitted. 

A packet types consists of $n$ member $x_1,\ldots, x_n$ and might look as follows:

\begin{lstlisting}[mathescape]
struct $\mathcal{A}$ {
	uint8_t  $x_{1}$      // # 8
	uint16_t $x_{2}$      // # 13
	uint8_t  $x_{3}$      // # 3
	uint32_t $x_{4}$      // # 23
};
\end{lstlisting}

If we choose to send\slash receive a packet of type $\mathcal{A}$, then
we only have to transmit $47 = 8 + 13 + 3 + 23$ bits instead of 64 bits.

In general, we denote the number of bits for a member $x_i$, with $1 \leq i \leq n$  by $a_i$.

\section{Decoder and Encoder}

For each packet type there is a \emph{decoder} and a \emph{encoder} function.
\begin{itemize}
\item
The decoder extracts the specified bits from the bit stream and stores them
in the individual packet members.
\item
The encoder, conversely, extracts the bits from the individual members
and writes them into the bit stream.
\end{itemize}

The extraction function of the decoder is referred to as \emph{peek},
whereas the extraction function of the encoder is referred to as \emph{poke}.
The number of calls to peek and poke and the parameters depend on the number
of variables and the required bit lengths.

For the packet $\mathcal{A}$ the Decoder looks as follows

\begin{lstlisting}[mathescape]
$\mathcal{A}$ Decoder(Bitstream stream) {
        $\mathcal{A}$ a;
	a.$x_{1}$ = peek (stream, 8);
	a.$x_{2}$ = peek (stream, 13);
	a.$x_{3}$ = peek (stream, 3);
	a.$x_{4}$ = peek (stream, 23);
}
\end{lstlisting}

\section{Bit Position}

The Decoder example is a very simplified version of an actual Decoder.
For the peek and poke calls we do actually need to set a bit position
that determines where in the stream the bits shall be read.
The bit position for each call depends on the bit position and length of the previous call.
For the packet $\mathcal{A}$ the bit position count up as follows:\\
variable   $a_{1}$, $a_{2}$, $a_{3}$, $a_{4}$\\
length      8, 13,  3, 23\\
bit position      0,  8, 21, 24\\
For each variable $x_{k}$ we can calculate the bit position $S_{k}$ as follows:
\begin{align*}
	&S_{k} = \sum_{i=1}^{k-1} a_{i}\\
	&S_{k+1} = S_{k} + a_{k}
\end{align*}

\section{Dynamic packets}

C structures of dynamic packets don't look any different from those of the previously introduced (static) packets.
The only difference is that, whether or not the value of a variable is of importance, may depend on the value of another variable.	
For example in our $\mathcal{A}$ packet, the value of $x_{3}$ may only be significant, if $x_{2}$ has a certain value.
Since some data may be useless we don't want to waste any bandwidth on our transmission media and therefore only transfer the needed data.
In the example we only want to transfer $x_{3}$ if $x_{2}$ has a certain value.
Our Decoder function looks something like that:

\begin{lstlisting}[mathescape]
$\mathcal{A}$ Decoder(Bitstream stream) {
        $\mathcal{A}$ a;
	a.$x_{1}$ = peek (stream, 8);
	a.$x_{2}$ = peek (stream, 13);
	if ($x_{2}$ == $\ldots$) {
		a.$x_{3}$ = peek (stream, 3);
	}
	a.$x_{4}$ = peek (stream, 23);
}
\end{lstlisting}

But how do we calculate the bit position for $x_{4}$, since it also depend on the value of $x_{2}$.

variable   $x_{1}$, $x_{2}$, $x_{3}$, $x_{4}$\\
length        8, 13, 3, 23\\
bit position\\
$x_{2} = \ldots  0, 8, 21, 24$\\
$x_{2} \neq \ldots  0, 8, 21, 21$\\

Maybe with the same if/else block:

\begin{lstlisting}[mathescape]
if ( $x_{2}$ == $\ldots$) {
	$S_{4}$ = $S_{3}$ + $a_{3}$
} else {
	$S_{4}$ = $S_{3}$
}
\end{lstlisting}

\section{Valid Array}

A different approach to the determination of bit position in dynamic packets is to create a boolean array, that holds a valid flag for each variable.
\begin{align*}
	&x_{1}, x_{2}, x_{3}, \ldots , x_{n}\\
	&v_{1}, v_{2}, v_{3}, \ldots , v_{n}	
\end{align*}
For a given packet $\mathcal{A}$ with a variable sequence $x_{1}, x_{2}, x_{3}, \ldots , x_{n}$ each $v_{i}$ determines whether or not variable $x_{i}$ was transferred.
Assuming we have a $V$-array, then we don't have to use the if-block.
Neither for the peek and poke nor for the bit position determination.
For each $x_{i}$ with $1\leq i\leq n$ we have the length of bits to read $a_{i}$ and the boolean $v_{i}$ that tells us whether or not the variable was transferred.
the Decoder look something like that:
\begin{lstlisting}[mathescape]
$\mathcal{A}$-Decoder (Bitstream stream, $\mathcal{A}$ a) {
	a.$x_{1}$ = peek (stream, 8 * $v_{1}$);
	a.$x_{2}$ = peek (stream, 13 * $v_{2}$);
	a.$x_{3}$ = peek (stream, 3 * $v_{3}$);
	a.$x_{4}$ = peek (stream, 23 * $v_{4}$);
}
\end{lstlisting}

\end{document}
